<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>Combinatorics Review</title>
  <style>
      code{white-space: pre-wrap;}
      span.smallcaps{font-variant: small-caps;}
      span.underline{text-decoration: underline;}
      div.column{display: inline-block; vertical-align: top; width: 50%;}
  </style>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.2/MathJax.js?config=TeX-AMS_CHTML-full" type="text/javascript"></script>
  <!--[if lt IE 9]>
    <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"></script>
  <![endif]-->
</head>
<body>
<header id="title-block-header">
<h1 class="title">Combinatorics Review</h1>
<p class="subtitle">June 2019</p>
</header>
<p>‘-r markdown+tex_math_single_backslash+simple_tables+table_captions+yaml_metadata_block+smart+blank_before_blockquote+backtick_code_blocks’</p>
<h1 id="formulae">Formulae</h1>
<p>Note that the theory is important for Combinatorics, just knowing what definitions are and what various expressions counts, but this is a very problem-driven subject! These are your tools – it is worth delineating exactly what kinds of problems are tractable, and which are more difficult. But the ultimate skill in this kind of course is to know when to apply which tool to a problem, how to translate problems into things you know how to count, and how to seamlessly move back and forth between various combinatorial interpretations.</p>
<p>So problems are the best practice!</p>
<h2 id="overview">Overview</h2>
<ul>
<li><p><span class="math inline">\(\theset{a, b, c, \cdots} = \theset{b, c, a, \cdots} = \theset{c, b, a, \cdots} = \cdots\)</span> is a <strong>set</strong>, a structure which contains some finite number of unique elements, and there is a-priori notion of “order” or an indexing operation (i.e. there is no distinguished “first” element, etc).</p></li>
<li><p>If <span class="math inline">\(S\)</span> is a set, then <span class="math inline">\(\# S\)</span> denotes the <strong>size</strong> of the set, i.e. a count of the number of elements contained in <span class="math inline">\(S\)</span>.</p></li>
<li><p><span class="math inline">\([a, b, c] \neq [b, c, a]\)</span> is an <strong>ordered list</strong> (also called a <span class="math inline">\(k\dash\)</span>tuple), a structure of not-necessarily unique elements from some set in which there is a well-defined order/indexing operation.</p>
<ul>
<li>For example, the second element of <span class="math inline">\([b,c,a]\)</span> is <span class="math inline">\(c\)</span>, and the first element of <span class="math inline">\([3,1,2]\)</span> is 3.</li>
<li>Equivalently, this can be thought of as a <strong>word</strong> from some <strong>alphabet</strong> of symbols. In this case, we may write <span class="math inline">\([a,b,c]\)</span> as <span class="math inline">\(abc\)</span> instead.</li>
<li>Rigorously, if <span class="math inline">\(A\)</span> is the set of elements we’re interested in, an ordered list is an element of the <span class="math inline">\(k\dash\)</span>fold product set <span class="math inline">\(A \cross A \cross \cdots A = A^k\)</span>.</li>
</ul></li>
</ul>
<hr />
<h2 id="sets">Sets</h2>
<p>For any given <span class="math inline">\(n\)</span>, there is essentially <strong>one</strong> set of size <span class="math inline">\(n\)</span>, the set <span class="math inline">\([n] = \theset{1,2,\cdots n}\)</span>. It is a theorem that every set admits a <em>well-ordering</em>, and a consequence of this is that any set <span class="math inline">\(S\)</span> of countable size <span class="math inline">\(n\)</span> admits a bijective map <span class="math inline">\(S \to [n]\)</span>. So <span class="math inline">\(S \cong [n]\)</span> in the category of Sets, “up to relabeling” of elements.</p>
<p>But be careful! <span class="math inline">\([n]\)</span> comes with its own labeling <strong>and </strong> its own ordering <span class="math inline">\(1 \leq 2 \leq \cdots\)</span>, and so should perhaps be regarded as an ordered list with unique elements instead. As a set, we can order the elements any way and obtain the same set.</p>
<h2 id="the-symmetric-group">The Symmetric Group</h2>
<p><span class="math inline">\(S_n\)</span> denotes the <strong>symmetric group</strong> on <span class="math inline">\(n\)</span> elements; each element of this group is a bijective function <span class="math inline">\([n]\to[n]\)</span>. Combinatorialists really love this group, and it secretly shows up in most counting problems.</p>
<p>A <strong>permutation</strong> <span class="math inline">\(\sigma\)</span> is an element of <span class="math inline">\(S_n\)</span>, We can specify a bijection by describing where it sends every element, so for example, define <span class="math display">\[\begin{aligned}
\sigma: [5] &amp;\to [5] &amp;\\ \\
\sigma(1) &amp;= 3 \implies &amp;1 \mapsto 3 \\
\sigma(2) &amp;= 4 \implies &amp;2 \mapsto 4 \\
\sigma(3) &amp;= 5 \implies &amp;3 \mapsto 5 \\
\sigma(4) &amp;= 2 \implies &amp;4 \mapsto 2 \\
\sigma(5) &amp;= 1 \implies &amp;5 \mapsto 1 \\
\end{aligned}\]</span> There are several more concise notations equivalent to the above specification:</p>
<h3 id="two-line-notation">Two line notation</h3>
<p>Write <span class="math inline">\(1\cdots n\)</span>, and under each number, write where it is sent to under <span class="math inline">\(\sigma\)</span>: <span class="math display">\[
\left( \begin{array}{ccccc}
1 &amp; 2 &amp; 3 &amp; 4 &amp; 5 \\
3 &amp; 4 &amp; 5 &amp; 2 &amp; 1
\end{array}\right)
\]</span> In general, we write <span class="math display">\[
\left( \begin{array}{cccc}
1 &amp; 2 &amp; \cdots &amp; n  \\
\sigma(1) &amp; \sigma(2) &amp; \cdots &amp; \sigma(n)
\end{array}\right)
\]</span></p>
<h3 id="one-line-notation">One line notation</h3>
<p>Noting that in the above notation, we’ll always write <span class="math inline">\(1\cdots n\)</span> in the top row, we can just omit it and implicitly agree that the <span class="math inline">\(k\dash\)</span>th position denotes where the integer <span class="math inline">\(k\)</span> is mapped to: <span class="math display">\[
[3,4,5,2,1] = 34521
\]</span></p>
<p>In general, we write a concatenated list of numbers <span class="math display">\[
\sigma(1)\sigma(2) \cdots \sigma(n)
\]</span></p>
<h3 id="cycle-notation">Cycle Notation</h3>
<p>Since <span class="math inline">\(S_n\)</span> is a finite group, we know that every element will have finite order. So for some given number <span class="math inline">\(i\)</span>, we can look at the iterates <span class="math inline">\(\sigma(i), \sigma^2(i) = \sigma(\sigma(i)), \sigma^3(i), \cdots\)</span> and there will be some <span class="math inline">\(k\)</span> for which <span class="math inline">\(\sigma^k(i) = i\)</span>. This sequence of images is called a <strong>cycle</strong>, and it turns out that we can recover our permutation entirely from exhaustively recording the cycles.</p>
<p>The algorithm: start with <span class="math inline">\(1\)</span>, then compute all <span class="math inline">\(\sigma^i(1)\)</span>. Write the resulting numbers in parentheses, then take the smallest number you haven’t seen yet, open a new parenthesis, and repeat until all numbers <span class="math inline">\(1 \cdots n\)</span> appear somewhere. Finally, if any set of parentheses contains only a single number (so <span class="math inline">\(\sigma(i) = i\)</span> after only 1 iteration), omit it.</p>
<p>Our example: <span class="math display">\[
(1,3,5)(2,4)
\]</span> which reads as “1 maps to 3, 3 maps to 5, 5 maps to 1” and “2 maps to 4, 4 maps to 2”.</p>
<p>In general, we write <span class="math display">\[
(1, \sigma(1), \sigma^2(1), \cdots, \sigma^{k}(1))~(a_1, \sigma(a_1), \sigma^2(a_1), \cdots, \sigma^{k_1}(a_1)) ~ \cdots
\]</span></p>
<p>Observations/notes:</p>
<ul>
<li>While <span class="math inline">\((abc) \neq (bac)\)</span> as cycles, we do have <span class="math inline">\((abc) = (cab) = (bca) = (abc)\)</span>. So order matters <em>somewhat</em>, but not every reordering yields a new distinct cycle. Instead, for a cycle <span class="math inline">\(\sigma\)</span> of length <span class="math inline">\(k\)</span>, there are exactly <span class="math inline">\(k-1\)</span> representatives that are equivalent to <span class="math inline">\(\sigma\)</span> and only differ by these “shifts”.</li>
<li>By writing things out this way, we’ve represented <span class="math inline">\(\sigma\)</span> as a <strong>product of disjoint cycles</strong>, i.e. no number occurs in more than one set of parentheses. Moreover, we can do this for every element <span class="math inline">\(\sigma\)</span>, so we say that <span class="math inline">\(S_n\)</span>.</li>
<li>It is sometimes useful to write these in a “canonical” way – shift every cycle so the largest elements are first, then sort the cycles in increasing order based on those first elements.</li>
</ul>
<h3 id="useful-facts-about-the-symmetric-group">Useful facts about the Symmetric group</h3>
<ul>
<li>Every element can be written as a product of disjoint cycles</li>
<li>Disjoint cycles commute</li>
<li>The group-theoretic order of a cycle is its length</li>
<li>The group-theoretic order of a product of cycles is the least common multiple of the lengths.</li>
</ul>
<h2 id="permutations">Permutations:</h2>
<p>We can count the number of bijections from an <span class="math inline">\(n\)</span> element set to itself: <span class="math display">\[ \#\theset{\text{Permutations of} [n]} = \abs{S_n}  = n! \]</span></p>
<ul>
<li>Also the number of a ways to form an <strong>ordered list</strong> of <span class="math inline">\(n\)</span> unique elements (<span class="math inline">\(n\)</span> choices for 1st element, <span class="math inline">\(n-1\)</span> choices for 2nd, etc).</li>
</ul>
<h2 id="ordered-lists">Ordered Lists</h2>
<p>If <span class="math inline">\(\#\Sigma = k\)</span> is some set (which we’ll regard as “formal symbols”), we can count the number of ordered lists: <span class="math display">\[
\# \theset{\text{Length $k$ lists over $\Sigma$}} = n^k
\]</span></p>
<ul>
<li>Logic: Suppose <span class="math inline">\(L = l_1 l_2, \cdots l_k\)</span>, then there are <span class="math inline">\(n\)</span> choices of symbol for <span class="math inline">\(l_1\)</span>, <span class="math inline">\(n\)</span> choices for <span class="math inline">\(l_2\)</span>, etc.</li>
<li>Also counts the number of words over an alphabet of size <span class="math inline">\(k\)</span>.</li>
</ul>
<h2 id="falling-factorial">Falling Factorial</h2>
<p>Let <span class="math display">\[\begin{aligned}
n^{\underline k} &amp;\definedas \prod_{i=0}^{k-1}(n - i) \\
&amp;= n(n-1)\cdots (n-k+1) \\
&amp;= \frac{n!}{(n-k)!}
\end{aligned}\]</span> be the <em>falling factorial</em>, which is a product with exactly <span class="math inline">\(n\)</span> terms.</p>
<ul>
<li>Counts the number of ways to form an <strong>ordered list</strong> of <span class="math inline">\(k\)</span> items from an <span class="math inline">\(n\)</span> element set (i.e. there is a distinguished “first” pick, “second” pick, etc)</li>
<li>Also counts the number of injections <span class="math inline">\([k] \injects [n]\)</span></li>
</ul>
<h2 id="rising-factorial">Rising Factorial</h2>
<p>Let <span class="math display">\[\begin{aligned}
n^{\overline k} &amp;\definedas \prod_{i=0}^{k-1}(n+i) \\ &amp;=n(n+1) \cdots (n+k-1)
\\&amp;= \frac{(n+k-1)!}{(n-1)!} \\ \\&amp;= (n+k-1)^{\underline k}
\end{aligned}\]</span> be the <em>rising factorial</em>, which is a product with exactly <span class="math inline">\(n\)</span> terms.</p>
<ul>
<li>Counts the number of ways to form an <strong>ordered list</strong> of <span class="math inline">\(k\)</span> items from an <span class="math inline">\(n+k-1\)</span> element set.</li>
</ul>
<h2 id="combinationsbinomial-coefficients">Combinations/Binomial Coefficients</h2>
<p>Counts the number of ways to form a <span class="math inline">\(k\dash\)</span>element <strong>subset</strong> of a set of <span class="math inline">\(n\)</span> items: <span class="math display">\[
\begin{aligned}
\#\theset{k\dash\text{element subsets of } [n]} = {n \choose k} &amp;\definedas \frac{n!}{k!(n-k!)} \\
&amp;= {n \choose n-k} \\ \\
&amp;= \frac{n^{\underline k}}{k!}
\end{aligned}
\]</span></p>
<ul>
<li>Note that order does <strong>not</strong> matter here; we identify any two sets that differ by a permutation
<ul>
<li>In other words, first form an ordered list of <span class="math inline">\(k\)</span> unique elements from <span class="math inline">\([n]\)</span> in <span class="math inline">\(n^{\underline k}\)</span> ways, then quotient out by the <span class="math inline">\(k!\)</span> ways to reorder the list that yield the same set.</li>
</ul></li>
<li>Alternatively, ways to pick <span class="math inline">\(k\)</span> items from <span class="math inline">\([n]\)</span> <strong>without replacement</strong>, then remove the labels.</li>
<li>Alternatively, the coefficient of <span class="math inline">\(x^k\)</span> in the expansion of <span class="math inline">\((1+x)^n\)</span>, i.e. <span class="math display">\[
(1+x)^n = \sum_{k\geq 0} {n\choose k} x^k
\]</span> which can be generalized to <span class="math display">\[
(x+y)^n = \sum_{k\geq 0} {n\choose k} x^ky^{n-k}
\]</span></li>
</ul>
<h3 id="generalized-binomial-coefficients">Generalized Binomial Coefficients</h3>
<p>We can extend the “choose” notation and thus the binomial formula to rational powers by defining <span class="math display">\[
{r \choose k} = \frac{1}{k!} \prod_{i=0}^{k-1} (r - i) = \frac{r(r-1)(r-2)\cdots(r-k+1)}{k!}\\
(x+y)^r = \sum_{k\geq 0} {r\choose k} x^ky^{n-k}
\]</span></p>
<p>Note that this allows us to expand things such as <span class="math inline">\(\sqrt{x+y} = (x+y)^\frac{1}{2}\)</span> in an infinite sum: <span class="math display">\[
\sqrt { 1 + x } = 1 + \frac { 1 } { 2 } x - \frac { 1 } { 8 } x ^ { 2 } + \frac { 1 } { 16 } x ^ { 3 } - \frac { 5 } { 128 } x ^ { 4 } + \frac { 7 } { 256 } x ^ { 5 } - \cdots
\]</span></p>
<h2 id="multisets">Multisets</h2>
<ul>
<li>What is a multiset? If <span class="math inline">\(S\)</span> is a set, you can think of a multiset <span class="math inline">\(M\)</span> as a word in the symbols <span class="math inline">\(s_i \in S\)</span> where order doesn’t matter.
<ul>
<li>Example: <span class="math inline">\(S = \theset{a,b,c}\)</span> and <span class="math inline">\(M = \theset{a,a,a,b,b} = \theset{a,b,a,a,b} = \cdots\)</span></li>
</ul></li>
<li>Alternatively, it is a collection of elements of <span class="math inline">\(S\)</span>, each with a multiplicity, so a subset of <span class="math inline">\(S \cross \NN\)</span>, where we define the size to be the sum of the multiplicities instead of (the usual) number of elements.
<ul>
<li>Example: As above, <span class="math inline">\(M = \theset{(a, 3), (b,2)}\)</span>. Note that although <span class="math inline">\(M\)</span> has size 2 as a set, it has size <span class="math inline">\(3+2 = 5\)</span> as a multiset.</li>
</ul></li>
</ul>
<p>We can thus count the number of <span class="math inline">\(k\dash\)</span>element multisets of an <span class="math inline">\(n\dash\)</span>element set: <span class="math display">\[\begin{aligned}
\#\theset{\text{Multisets of $[n]$ of size $k$} } &amp;= \multinomial{n\choose k} \\ &amp;\definedas {{n+k-1}\choose k} \\ &amp;= {{n+k-1}\choose n-1} \\ \\ &amp;= \frac{n^{\overline k}}{k!}
\end{aligned}\]</span></p>
<p><em>Proof</em>: Multisets can be put in bijection with unrestricted stars and bars arrangements, see next section. <span class="math inline">\(\qed\)</span></p>
<ul>
<li>The number <span class="math inline">\(\multinomial{n\choose k}\)</span> is denoted a <strong>multinomial coefficient</strong>.</li>
<li>Also counts the number of ways to select <span class="math inline">\(k\)</span> items <strong>with replacement</strong> from a set of size <span class="math inline">\(n\)</span>.</li>
</ul>
<h2 id="catalan-numbers">Catalan Numbers</h2>
<p>Consider the problem of counting the number of <span class="math inline">\(n\times n\)</span> lattice paths that don’t go above the diagonal. Since every such path has to have a “first hitting time” for the diagonal, we can enumerate these using a recurrence relation. Let <span class="math inline">\(C_n\)</span> be the number of such paths. If the first hit occurs on the <span class="math inline">\(k\)</span>th diagonal, then there were <span class="math inline">\(C_k\)</span> paths leading there and <span class="math inline">\(C_{n-k}\)</span> paths to the top-right corner. This yields <span class="math display">\[
C_{n+1} = \sum_{i=0}^n C_i C_{n-i}
\]</span> and using generating functions, it can be shown that <span class="math display">\[
C_n = \frac{1}{n+1}{2n \choose n}
\]</span></p>
<h2 id="stars-and-bars">Stars and Bars</h2>
<p>A useful conceptual counting problem, as many other problems can be encoded as some version of this. The idea is we have an alphabet <span class="math inline">\(\Sigma = \theset{\star, \mid}\)</span> (“star” and “bar”), and we’d like to form certain words containing exactly <span class="math inline">\(n\)</span> copies of <span class="math inline">\(\star\)</span> and <span class="math inline">\(k\)</span> copies of <span class="math inline">\(\mid\)</span>.</p>
<p>There are two variants: we’ll say a configuration of stars and bars is <em>strict</em> if a bar does not occur as the first or last symbol, and there are no two adjacent bars.</p>
<h3 id="variant-1-strict">Variant 1: Strict</h3>
<p>This can be counted as <span class="math display">\[
\#\theset{\text{strict configurations of $n$ stars and $k-1$ bars}} = {n-1 \choose k-1}
\]</span></p>
<p><em>Proof</em>: Lay out <span class="math inline">\(n\)</span> stars, which have <span class="math inline">\(n-1\)</span> gaps between them. From these gaps, choose any <span class="math inline">\(k-1\)</span> of them (without replacement) to contain bars.<span class="math inline">\(\qed\)</span></p>
<ul>
<li>Note that this partitions the <span class="math inline">\(n\)</span> stars into <span class="math inline">\(k\)</span> nonempty groups, so this counts the number of ways to separate <span class="math inline">\(n\)</span> indistinguishable objects into <span class="math inline">\(k\)</span> nonempty groups,</li>
<li>Alternatively, counts the number of compositions of <span class="math inline">\(n\)</span> into <span class="math inline">\(k\)</span> parts.</li>
</ul>
<h3 id="variant-2-unrestricted">Variant 2: Unrestricted</h3>
<p>With no restrictions of the configuration, we can count <span class="math display">\[
\#\theset{\text{unrestricted configurations of $n$ stars and $k-1$ bars}} = {n+k-1 \choose k-1}
\]</span></p>
<p><em>Proof</em>: Since we just need to form an arbitrary word from <span class="math inline">\(n\)</span> stars and <span class="math inline">\(k-1\)</span> bars, simply place <span class="math inline">\(n + (k-1)\)</span> blanks, choose <span class="math inline">\(k-1\)</span> of them (without replacement) to be bars, and place stars everywhere else.</p>
<p><em>Alternate proof</em>: Lay out <span class="math inline">\(n\)</span> stars, then from the <span class="math inline">\(n-1\)</span> gaps, choose <span class="math inline">\(k-1\)</span> gaps with replacement to contain bars. This can be done in <span class="math inline">\(\multinomial{n-1 \choose k-1} = {n+k-1 \choose k-1}\)</span> ways. <span class="math inline">\(\qed\)</span></p>
<ul>
<li>Note that this partitions <span class="math inline">\(n\)</span> stars into <span class="math inline">\(k\)</span> groups, some of which may be empty.</li>
<li>Alternatively, counts the number of weak compositions of <span class="math inline">\(n\)</span> into <span class="math inline">\(k\)</span> parts.</li>
</ul>
<h2 id="stirling-numbers-of-the-first-kind">Stirling Numbers of the First Kind</h2>
<p>For a given <span class="math inline">\(n\)</span>, consider permutations <span class="math inline">\(\sigma \in S_n\)</span>. It can be written as a product of disjoint cycles in cycle notation, so one can ask how many permutations have exactly <span class="math inline">\(k\)</span> disjoint cycles. In other words, we have <span class="math display">\[
\sigma = \overbrace{(a_1b_1\cdots)(a_2b_2\cdots)\cdots(a_kb_k\cdots)}^{k \text{ cycles}} \in S_n
\]</span> in cycle notation, where we include cycles of length 1 (i.e. fixed points). We can thus count <span class="math display">\[
\#\theset{\text{permutations of $[n]$ with exactly $k$ disjoint cycles}} \definedas c(n, k) = \stirlingfirst{n}{k}
\]</span> the <strong>unsigned Stirling number of the first kind</strong>.</p>
<blockquote>
<p>In other applications, there is a <strong>signed Stirling number of the first kind</strong> which are related by <span class="math display">\[
s(n, k) \definedas (-1)^{n-k}c(n, k), \quad \abs{s(n,k)} = c(n, k)
\]</span> These yield the coefficients of <span class="math inline">\(x^n\)</span> in the falling factorial <span class="math inline">\(x^{\underline n} = x(x-1)\cdots(x-n+1)\)</span>.</p>
</blockquote>
<p>There isn’t a particularly nice closed form expression for <span class="math inline">\(c(n, k)\)</span>, so the main computational tool is the following recurrence relation they satisfy: <span class="math display">\[
\stirlingfirst n k = (n-1){\stirlingfirst {n-1} k} + \stirlingfirst{n-1}{k-1}
\]</span> <em>Proof:</em> Either <span class="math inline">\(n\)</span> is a fixed point (i.e. in a cycle by itself) or it is not.</p>
<ul>
<li>If <span class="math inline">\(n\)</span> is a fixed point, we can delete the cycle <span class="math inline">\((n)\)</span> from <span class="math inline">\(\sigma\)</span> to obtain a permutation of <span class="math inline">\([n-1]\)</span> with <span class="math inline">\(k-1\)</span> cycles. Conversely, we can lift any permutation of <span class="math inline">\([n-1]\)</span> with <span class="math inline">\(k-1\)</span> cycles to a permutation of <span class="math inline">\([n]\)</span> by just adding the cycle <span class="math inline">\((n)\)</span>, which can only be done in one way, yielding the second term</li>
<li>Otherwise, <span class="math inline">\(n\)</span> appears in a cycle with other elements. We can delete it to obtain a permutation of <span class="math inline">\([n-1]\)</span> which still has <span class="math inline">\(k\)</span> cycles; conversely, given such a permutation, consider the operation of multiplying <span class="math inline">\(\sigma\)</span> by the transposition <span class="math inline">\((n~i)\)</span> where <span class="math inline">\(1\leq i\leq n-1\)</span>. This has the effect of inserting <span class="math inline">\(n\)</span> into the cycle containing <span class="math inline">\(i\)</span>, and in fact puts it right before <span class="math inline">\(i\)</span>, i.e. <span class="math display">\[
(a_1 a_2 \cdots a_{k}~ i ~ a_{k+1} \cdots a_m)(n~i) =  (a_1 a_2 \cdots a_{k}~ n ~ i ~ a_{k+1} \cdots a_m).
\]</span> There are exactly <span class="math inline">\(n-1\)</span> choices for <span class="math inline">\(i\)</span>, and each one yields a way to insert <span class="math inline">\(n\)</span> into an existing cycle, yielding the first term. <span class="math inline">\(\qed\)</span></li>
</ul>
<h2 id="stirling-numbers-of-the-second-kind">Stirling Numbers of the Second Kind</h2>
<p>A <strong>set partition of <span class="math inline">\([n]\)</span> into <span class="math inline">\(k\)</span> parts</strong> is a collection <span class="math inline">\(S_1, S_2, \cdots S_k\)</span> where</p>
<ul>
<li><span class="math inline">\(S_i \subseteq [n]\)</span> for each <span class="math inline">\(i\)</span></li>
<li><span class="math inline">\(S_i \neq \emptyset\)</span> for any <span class="math inline">\(i\)</span>,</li>
<li><span class="math inline">\(S_i \intersect S_j = \emptyset\)</span> for all pairs <span class="math inline">\(1 \leq i,j \leq k\)</span> (so all of the <span class="math inline">\(S_i\)</span> are disjoint), and</li>
<li><span class="math inline">\([n] = S_1 \disjoint S_2 \disjoint \cdots \disjoint S_k\)</span></li>
</ul>
<p>We can then count <span class="math display">\[
\#\theset{\text{Set partitions of $[n]$ into $k$ parts}} \definedas S(n, k) = \stirling n k,
\]</span> which is referred to as the Stirling number of the second kind. Although there is a closed-form formula for it, it is not particulary nice – the primary method of computing it comes from a recurrence relation it satisfies: <span class="math display">\[
\stirling n k = k\stirling {n-1} {k} + \stirling{n-1}{k-1}
\]</span></p>
<p><em>Proof (with a valuable technique!)</em>: When forming a set partition of <span class="math inline">\([n]\)</span> into <span class="math inline">\(k\)</span> parts, there are two disjoint cases: either <span class="math inline">\(n\)</span> is in a singleton set, or it is not.</p>
<ul>
<li>If <span class="math inline">\(n\)</span> a singleton, throw that part away. What remains is a partition of <span class="math inline">\(n-1\)</span> into <span class="math inline">\(k-1\)</span> parts. Conversely, given any partition of <span class="math inline">\(n-1\)</span> into <span class="math inline">\(k-1\)</span> parts, we can add the part <span class="math inline">\(\theset{n}\)</span> to obtain a partition of <span class="math inline">\(n\)</span> into <span class="math inline">\(k\)</span> parts where <span class="math inline">\(n\)</span> is a singleton. This yields the second term.</li>
<li>If it is not, <span class="math inline">\(n\)</span> is some <span class="math inline">\(S_i\)</span> with at least 1 other element. Letting <span class="math inline">\(S&#39;_i = S_i - \theset{n} \neq \emptyset\)</span> we get a partition of <span class="math inline">\(n-1\)</span> into <span class="math inline">\(k\)</span> parts. Conversely, given any partition of <span class="math inline">\(n-1\)</span> into <span class="math inline">\(k\)</span> parts, we can form a partition of <span class="math inline">\(n\)</span> into <span class="math inline">\(k\)</span> parts where <span class="math inline">\(n\)</span> is not a singleton by adding <span class="math inline">\(n\)</span> to any part. Note that there are <span class="math inline">\(k\)</span> choices for which part to add <span class="math inline">\(n\)</span> to, yielding the first term. <span class="math inline">\(\qed\)</span></li>
</ul>
<h2 id="compositions">Compositions</h2>
<p>In general, a composition is a way of writing <span class="math inline">\(n\)</span> as a sum of positive integers, i.e. <span class="math inline">\(n = a_1 + a_2 + \cdots\)</span> where <span class="math inline">\(a_i \in \ZZ\)</span>. There are infinitely many of these, so to count anything, we need to place various restrictions:</p>
<h3 id="strong-compositions">Strong Compositions</h3>
<p>A <strong>composition of <span class="math inline">\(n\)</span> into <span class="math inline">\(k\)</span> parts</strong> is an <strong>ordered list</strong> <span class="math inline">\([a_1, a_2, \cdots a_k]\)</span> such that <span class="math inline">\(\sum_{i=1}^k a_i = n\)</span> and for each <span class="math inline">\(i\)</span> we have <span class="math inline">\(0 &lt; a_i \leq n\)</span>. (Note that we <strong>do not</strong> allow any <span class="math inline">\(a_i\)</span> to be zero now.)</p>
<p>These can be counted as <span class="math display">\[
\mathrm{comp}(n, k) = \#\theset{\text{compositions of $n$ into $k$ parts}} \\
= \multinomial{n+1 \choose k-1} \\ = {n+k-1 \choose k}
\]</span> where <span class="math inline">\(\multinomial{a \choose b}\)</span> is the multinomial coefficient. This follows from by a bijection with strict stars and bars configurations. Note that distinct lists yields distinct compositions.</p>
<h3 id="weak-compositions">Weak Compositions</h3>
<p>A <strong>weak composition of <span class="math inline">\(n\)</span> into <span class="math inline">\(k\)</span> parts</strong> is an <strong>ordered list</strong> <span class="math inline">\([a_1, a_2, \cdots a_k]\)</span> such that<span class="math inline">\(\sum_{i=1}^k a_i = n\)</span> and for each <span class="math inline">\(i\)</span> we have <span class="math inline">\(0 \leq a_i \leq n\)</span>. (Note that we allow some <span class="math inline">\(a_i\)</span> to be zero.)</p>
<p>These can be counted as <span class="math display">\[
\mathrm{comp}_W(n, k)  = \#\theset{\text{weak compositions of $n$ into $k$ parts}} \\
= {n-1 \choose n-k},
\]</span> which follows from a bijection with unrestricted stars and bars configurations. Note that distinct lists yields distinct compositions.</p>
<h3 id="integer-partitions">Integer Partitions</h3>
<p>An <strong>integer partition of <span class="math inline">\(n\)</span> into <span class="math inline">\(k\)</span> parts</strong> is a strong composition of <span class="math inline">\(n\)</span> into <span class="math inline">\(k\)</span> parts where we identify any compositions that differ by a permutation of of parts. In other words, it is a <strong>set</strong> of integers <span class="math inline">\([a_1, a_2, \cdots a_k]\)</span> such that <span class="math inline">\(\sum_{i=1}^k a_i = n\)</span> and for each i, <span class="math inline">\(1 \leq a_i \leq n\)</span>.</p>
<p><em>Example</em>: The strong compositions of 4 are</p>
<p><code>python {cmd="/usr/bin/sage"} from sage.all import * print(sorted(list(Compositions(4)), key=len))</code></p>
<p>while the integer partitions are</p>
<p><code>python {cmd="/usr/bin/sage"} from sage.all import * print(sorted(list(Partitions(4)), key=len))</code></p>
<p>Note that <span class="math inline">\([3,1]\)</span> and <span class="math inline">\([1,3]\)</span> are distinct as compositions of 4 into 2 parts, but are identified as partitions of 4 into 2 parts.</p>
<p>These are generally difficult to count, but we can define <span class="math display">\[\begin{aligned}
\# \theset{\text{Integer partitions of $n$ into $k$ parts}} &amp;\definedas p(n, k) \\
\# \theset{\text{Integer partitions of $n$ into any number of parts}} &amp;\definedas p(n).
\end{aligned}\]</span></p>
<p>Integer partitions are in bijective correspondence with <strong>Ferrer’s diagrams</strong>, which provide many useful ways of extracting information via diagram operations. The most important operation is <strong>conjugation</strong>, which is flipping a diagram about its main diagonal. This operation can be used to prove the following bijections between types of integer partitions:</p>
<p><span class="math display">\[\begin{aligned}
\#\theset{\text{Exactly $k$ parts}} &amp;= \#\theset{\text{Largest part $= k$}}\\
\#\theset{\text{Any number of parts, where every part is $\leq k$}} &amp;= \#\theset{\text{At most $k$ parts}} \\
\#\theset{\text{Any number of distinct, odd parts}} &amp;= \#\theset{\text{Self-conjugate partitions}}
\end{aligned}\]</span></p>
<p><span class="citation" data-cites="import">@import</span> “./GeneratingFunctions.md”</p>
<p><span class="citation" data-cites="import">@import</span> “./Posets.md”</p>
<hr />
<h1 id="appendix">Appendix</h1>
<p>Some notes on lists:</p>
<ul>
<li>Note that every <span class="math inline">\(n\dash\)</span>element list admits an action of <span class="math inline">\(S_n\)</span> where you let any <span class="math inline">\(\sigma\in S_n\)</span> act on the indices (i.e. reordering the list).</li>
<li>Note that there is a map from lists to sets, which just forms a set out of the element of the list. For example, <span class="math inline">\([a,b,c,b] \mapsto \theset{a,b,c}\)</span>. Note that it is not injective in general, since for example <span class="math inline">\([c,b,b,a] \mapsto \theset{a,b,c}\)</span> as well. If the <span class="math inline">\(n\)</span> elements of list are <em>unique</em>, however, then the action of <span class="math inline">\(S_n\)</span> is nice enough that you can quotient out by it, i.e. dividing counts by <span class="math inline">\(n!\)</span>.</li>
<li>So one method of counting is to first form an ordered list of unique elements, then identify any two ordered lists if they differ by a permutation (i.e. take the underlying set).</li>
</ul>
<p>Bonus: It can be shown using ordinary generating functions that <span class="math display">\[
\stirlingfirst{n}{k} = \frac { 1 } { k ! } \ln ^ { k } \left( \frac { 1 } { 1 - z } \right).
\]</span></p>
<p>Bonus: a closed formula for the Stirling numbers of the second kind is given by <span class="math display">\[
\stirling n k = \sum _ { i = 0 } ^ { k } \frac { ( - 1 ) ^ { k - i } } { k ! } \left( \begin{array} { l } { k } \\ { i } \end{array} \right) i ^ { n },
\]</span> which can be found by using the recurrence to solve for an ordinary generating function, then using partial fraction decomposition and some gnarly algebraic manipulations. With a bit more work, you can show <span class="math display">\[
\sum_k \stirling n k = \frac 1 e \sum_{i=0}^\infty \frac{i^n}{i!}.
\]</span></p>
</body>
</html>
